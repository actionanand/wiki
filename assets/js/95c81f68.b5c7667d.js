"use strict";(self.webpackChunkwiki=self.webpackChunkwiki||[]).push([[6307],{62850:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"js-tips/decorator","title":"Decorator in Typescript","description":"A decorator in TypeScript is a special kind of declaration that can be attached to a class, method, accessor, property, or parameter. Decorators allow you to modify or enhance the behavior of the target they are applied to. They are widely used in frameworks like Angular for dependency injection, metadata, and more.","source":"@site/docs/js-tips/decorator.md","sourceDirName":"js-tips","slug":"/js-tips/decorator","permalink":"/wiki/docs/js-tips/decorator","draft":false,"unlisted":false,"editUrl":"https://github.com/actionanand/wiki/docs/js-tips/decorator.md","tags":[],"version":"current","sidebarPosition":13,"frontMatter":{"sidebar_position":13,"sidebar_label":"Decorator in Typescript"},"sidebar":"tutorialSidebar","previous":{"title":"String Manipulation part-3","permalink":"/wiki/docs/js-tips/string-manipulation-3"},"next":{"title":"Hacker Rank part-1","permalink":"/wiki/docs/js-tips/hacker-rank"}}');var s=r(74848),o=r(28453);const i={sidebar_position:13,sidebar_label:"Decorator in Typescript"},a="Decorator in Typescript",c={},l=[{value:"Decorators",id:"decorators",level:2},{value:"<strong>Syntax</strong>",id:"syntax",level:3},{value:"<strong>Types of Decorators</strong>",id:"types-of-decorators",level:3},{value:"<strong>Practical Example: Logging Decorator</strong>",id:"practical-example-logging-decorator",level:3},{value:"<strong>Key Points</strong>",id:"key-points",level:3},{value:"Factory Function in a Decorator",id:"factory-function-in-a-decorator",level:2},{value:"<strong>Example: Logging Decorator with a Factory Function</strong>",id:"example-logging-decorator-with-a-factory-function",level:3},{value:"<strong>Explanation</strong>",id:"explanation",level:3},{value:"<strong>Key Points</strong>",id:"key-points-1",level:3},{value:"difference between experimental and ECMAScript decorators",id:"difference-between-experimental-and-ecmascript-decorators",level:2},{value:"<strong>1. Experimental Decorators</strong>",id:"1-experimental-decorators",level:3},{value:"<strong>Example</strong>:",id:"example",level:4},{value:"<strong>Key Points</strong>:",id:"key-points-2",level:4},{value:"<strong>2. ECMAScript Decorators</strong>",id:"2-ecmascript-decorators",level:3},{value:"<strong>Example</strong>:",id:"example-1",level:4},{value:"<strong>Key Points</strong>:",id:"key-points-3",level:4},{value:"<strong>Key Differences</strong>",id:"key-differences",level:3},{value:"<strong>Which One Should You Use?</strong>",id:"which-one-should-you-use",level:3},{value:"<strong>Conclusion</strong>",id:"conclusion",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"decorator-in-typescript",children:"Decorator in Typescript"})}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.strong,{children:"decorator"})," in TypeScript is a special kind of declaration that can be attached to a class, method, accessor, property, or parameter. Decorators allow you to modify or enhance the behavior of the target they are applied to. They are widely used in frameworks like Angular for dependency injection, metadata, and more."]}),"\n",(0,s.jsx)(n.p,{children:"TypeScript decorators are an extension that allows adding annotation and metaprogramming to class declarations and their members in TypeScript. TypeScript supports decorators syntax as an experimental feature which is distinct from JavaScript decorators that is currently a Stage 3 ECMAScript proposal."}),"\n",(0,s.jsx)(n.p,{children:"There are six stages in the ECMAScript proposal process: Stage 0 (Strawman), Stage 1, Stage 2, Stage 3, and Stage 4. A proposal must progress through all these stages, and TC39 (the technical committee) must approve its movement to the next stage."}),"\n",(0,s.jsx)(n.p,{children:"Metaprogramming in programming languages refers to writing code that manipulates or generates other code. Decorators in Typescript are a specific example of metaprogramming, allowing you to modify the behavior of functions or classes without directly changing their code. They are used to add functionality to existing objects, much like the Decorator design pattern."}),"\n",(0,s.jsx)(n.h2,{id:"decorators",children:"Decorators"}),"\n",(0,s.jsx)(n.h3,{id:"syntax",children:(0,s.jsx)(n.strong,{children:"Syntax"})}),"\n",(0,s.jsxs)(n.p,{children:["Decorators are prefixed with the ",(0,s.jsx)(n.code,{children:"@"})," symbol and are functions that are executed at runtime."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"@decorator\nclass MyClass {\n  @decorator\n  myMethod() {}\n}\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"types-of-decorators",children:(0,s.jsx)(n.strong,{children:"Types of Decorators"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Class Decorators"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Applied to a class."}),"\n",(0,s.jsx)(n.li,{children:"Used to modify or annotate the class."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'function ClassDecorator(constructor: Function) {\n  console.log("ClassDecorator called");\n}\n\n@ClassDecorator\nclass MyClass {}\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Output"}),": Logs ",(0,s.jsx)(n.code,{children:'"ClassDecorator called"'})," when the class is defined."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Method Decorators"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Applied to a method."}),"\n",(0,s.jsx)(n.li,{children:"Used to modify or observe the behavior of a method."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'function MethodDecorator(target: Object, propertyKey: string, descriptor: PropertyDescriptor) {\n  console.log(`MethodDecorator called on: ${propertyKey}`);\n}\n\nclass MyClass {\n  @MethodDecorator\n  myMethod() {\n    console.log("Executing myMethod");\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Output"}),": Logs ",(0,s.jsx)(n.code,{children:'"MethodDecorator called on: myMethod"'})," when the class is defined."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Property Decorators"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Applied to a property."}),"\n",(0,s.jsx)(n.li,{children:"Used to observe or modify the behavior of a property."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'function PropertyDecorator(target: Object, propertyKey: string) {\n  console.log(`PropertyDecorator called on: ${propertyKey}`);\n}\n\nclass MyClass {\n  @PropertyDecorator\n  myProperty: string = "Hello";\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Output"}),": Logs ",(0,s.jsx)(n.code,{children:'"PropertyDecorator called on: myProperty"'})," when the class is defined."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.ol,{start:"4",children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Accessor Decorators"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Applied to a getter or setter."}),"\n",(0,s.jsx)(n.li,{children:"Used to modify or observe the behavior of an accessor."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"function AccessorDecorator(target: Object, propertyKey: string, descriptor: PropertyDescriptor) {\n  console.log(`AccessorDecorator called on: ${propertyKey}`);\n}\n\nclass MyClass {\n  private _value: number = 0;\n\n  @AccessorDecorator\n  get value() {\n    return this._value;\n  }\n\n  set value(val: number) {\n    this._value = val;\n  }\n}\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.ol,{start:"5",children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameter Decorators"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Applied to a method parameter."}),"\n",(0,s.jsx)(n.li,{children:"Used to observe or modify metadata about a parameter."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"function ParameterDecorator(target: Object, propertyKey: string, parameterIndex: number) {\n  console.log(`ParameterDecorator called on: ${propertyKey}, parameter index: ${parameterIndex}`);\n}\n\nclass MyClass {\n  myMethod(@ParameterDecorator param: string) {\n    console.log(param);\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Output"}),": Logs ",(0,s.jsx)(n.code,{children:'"ParameterDecorator called on: myMethod, parameter index: 0"'})," when the class is defined."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"practical-example-logging-decorator",children:(0,s.jsx)(n.strong,{children:"Practical Example: Logging Decorator"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"function Log(target: Object, propertyKey: string, descriptor: PropertyDescriptor) {\n  const originalMethod = descriptor.value;\n\n  descriptor.value = function (...args: any[]) {\n    console.log(`Method ${propertyKey} called with arguments: ${args}`);\n    return originalMethod.apply(this, args);\n  };\n\n  return descriptor;\n}\n\nclass Calculator {\n  @Log\n  add(a: number, b: number): number {\n    return a + b;\n  }\n}\n\nconst calc = new Calculator();\nconsole.log(calc.add(2, 3)); // Logs: Method add called with arguments: 2,3\n                             // Output: 5\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"key-points",children:(0,s.jsx)(n.strong,{children:"Key Points"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Metadata Reflection"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"TypeScript decorators often work with metadata."}),"\n",(0,s.jsxs)(n.li,{children:["You can use the ",(0,s.jsx)(n.code,{children:"reflect-metadata"})," library to store and retrieve metadata."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'import "reflect-metadata";\n\nfunction MetadataDecorator(target: Object, propertyKey: string) {\n  Reflect.defineMetadata("custom:metadata", "value", target, propertyKey);\n}\n\nclass MyClass {\n  @MetadataDecorator\n  myProperty: string;\n}\n\nconsole.log(Reflect.getMetadata("custom:metadata", MyClass.prototype, "myProperty")); // Output: "value"\n'})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Order of Execution"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Decorators are applied in the following order:","\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Parameter Decorators"}),"\n",(0,s.jsx)(n.li,{children:"Method/Accessor Decorators"}),"\n",(0,s.jsx)(n.li,{children:"Property Decorators"}),"\n",(0,s.jsx)(n.li,{children:"Class Decorators"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Experimental Feature"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Decorators are an experimental feature in TypeScript and require enabling the ",(0,s.jsx)(n.code,{children:"experimentalDecorators"})," compiler option in tsconfig.json:","\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "compilerOptions": {\n    "experimentalDecorators": true\n  }\n}\n'})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Decorators are a powerful feature for adding metadata, modifying behavior, and implementing cross-cutting concerns like logging, validation, and dependency injection."}),"\n",(0,s.jsx)(n.h2,{id:"factory-function-in-a-decorator",children:"Factory Function in a Decorator"}),"\n",(0,s.jsx)(n.p,{children:"A factory function allows you to pass parameters to a decorator. It returns the actual decorator function."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"example-logging-decorator-with-a-factory-function",children:(0,s.jsx)(n.strong,{children:"Example: Logging Decorator with a Factory Function"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'function Log(message: string) {\n  // This is the factory function\n  return function (target: Object, propertyKey: string, descriptor: PropertyDescriptor) {\n    const originalMethod = descriptor.value;\n\n    descriptor.value = function (...args: any[]) {\n      console.log(`${message} - Method ${propertyKey} called with arguments: ${args}`);\n      return originalMethod.apply(this, args);\n    };\n\n    return descriptor;\n  };\n}\n\nclass Calculator {\n  @Log("Addition Operation")\n  add(a: number, b: number): number {\n    return a + b;\n  }\n\n  @Log("Multiplication Operation")\n  multiply(a: number, b: number): number {\n    return a * b;\n  }\n}\n\n// Example usage\nconst calc = new Calculator();\nconsole.log(calc.add(2, 3)); // Logs: "Addition Operation - Method add called with arguments: 2,3"\n                             // Output: 5\nconsole.log(calc.multiply(4, 5)); // Logs: "Multiplication Operation - Method multiply called with arguments: 4,5"\n                                  // Output: 20\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"explanation",children:(0,s.jsx)(n.strong,{children:"Explanation"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Factory Function"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"Log"})," function is a factory function that takes a ",(0,s.jsx)(n.code,{children:"message"})," parameter."]}),"\n",(0,s.jsx)(n.li,{children:"It returns the actual decorator function."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Decorator Function"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The returned function is the actual decorator that modifies the method."}),"\n",(0,s.jsx)(n.li,{children:"It wraps the original method and adds logging functionality."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"How It Works"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["When the ",(0,s.jsx)(n.code,{children:"add"})," or ",(0,s.jsx)(n.code,{children:"multiply"})," method is called, the decorator logs the custom message and the method arguments before executing the original method."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"key-points-1",children:(0,s.jsx)(n.strong,{children:"Key Points"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Factory functions allow decorators to be dynamic and configurable."}),"\n",(0,s.jsx)(n.li,{children:"You can pass parameters to the factory function to customize the behavior of the decorator."}),"\n",(0,s.jsx)(n.li,{children:"This approach is commonly used in frameworks like Angular for dependency injection and metadata configuration."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"difference-between-experimental-and-ecmascript-decorators",children:"difference between experimental and ECMAScript decorators"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.strong,{children:"difference between experimental decorators"})," and ",(0,s.jsx)(n.strong,{children:"ECMAScript decorators"})," in TypeScript lies in their implementation, syntax, and alignment with the ECMAScript standard. Here's a detailed comparison:"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"1-experimental-decorators",children:(0,s.jsx)(n.strong,{children:"1. Experimental Decorators"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Introduced"}),": TypeScript's experimental decorators were introduced before the ECMAScript proposal for decorators was finalized."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Status"}),": Non-standard and based on an earlier stage of the ECMAScript proposal."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Syntax"}),": Uses the ",(0,s.jsx)(n.code,{children:"@decorator"})," syntax."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Behavior"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Allows decorating classes, methods, properties, accessors, and parameters."}),"\n",(0,s.jsxs)(n.li,{children:["Requires enabling the ",(0,s.jsx)(n.code,{children:"experimentalDecorators"})," compiler option in tsconfig.json."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"example",children:[(0,s.jsx)(n.strong,{children:"Example"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"function Log(target: Object, propertyKey: string, descriptor: PropertyDescriptor) {\n  const originalMethod = descriptor.value;\n\n  descriptor.value = function (...args: any[]) {\n    console.log(`Method ${propertyKey} called with arguments: ${args}`);\n    return originalMethod.apply(this, args);\n  };\n\n  return descriptor;\n}\n\nclass Calculator {\n  @Log\n  add(a: number, b: number): number {\n    return a + b;\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"key-points-2",children:[(0,s.jsx)(n.strong,{children:"Key Points"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Metadata Reflection"}),": Often used with the ",(0,s.jsx)(n.code,{children:"reflect-metadata"})," library for storing and retrieving metadata."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Order of Execution"}),": Follows a specific order (parameter \u2192 method/accessor \u2192 property \u2192 class)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Compiler Option"}),": Requires ",(0,s.jsx)(n.code,{children:'"experimentalDecorators": true'})," in tsconfig.json."]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"2-ecmascript-decorators",children:(0,s.jsx)(n.strong,{children:"2. ECMAScript Decorators"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Introduced"}),": Based on the finalized ECMAScript proposal for decorators (Stage 3+)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Status"}),": Standardized and aligned with the ECMAScript specification."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Syntax"}),": Uses the ",(0,s.jsx)(n.code,{children:"@decorator"})," syntax but with stricter rules and a different API."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Behavior"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Focuses on class elements (methods, fields, accessors)."}),"\n",(0,s.jsx)(n.li,{children:"Does not support parameter decorators."}),"\n",(0,s.jsxs)(n.li,{children:["Requires enabling the ",(0,s.jsx)(n.code,{children:"useDefineForClassFields"})," compiler option in tsconfig.json."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"example-1",children:[(0,s.jsx)(n.strong,{children:"Example"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"function Log(value: any, context: ClassMethodDecoratorContext) {\n  const originalMethod = value;\n\n  return function (...args: any[]) {\n    console.log(`Method ${context.name} called with arguments: ${args}`);\n    return originalMethod.apply(this, args);\n  };\n}\n\nclass Calculator {\n  @Log\n  add(a: number, b: number): number {\n    return a + b;\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"key-points-3",children:[(0,s.jsx)(n.strong,{children:"Key Points"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Metadata Reflection"}),": Does not rely on ",(0,s.jsx)(n.code,{children:"reflect-metadata"})," by default."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Context Object"}),": Provides a ",(0,s.jsx)(n.code,{children:"context"})," object with metadata about the decorated element (e.g., ",(0,s.jsx)(n.code,{children:"name"}),", ",(0,s.jsx)(n.code,{children:"kind"}),")."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Compiler Option"}),": Requires ",(0,s.jsx)(n.code,{children:'"experimentalDecorators": true'})," and ",(0,s.jsx)(n.code,{children:'"useDefineForClassFields": true'})," in tsconfig.json."]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"key-differences",children:(0,s.jsx)(n.strong,{children:"Key Differences"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Feature"}),(0,s.jsx)(n.th,{children:"Experimental Decorators"}),(0,s.jsx)(n.th,{children:"ECMAScript Decorators"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Standardization"})}),(0,s.jsx)(n.td,{children:"Non-standard (TypeScript-specific)"}),(0,s.jsx)(n.td,{children:"Standardized (aligned with ECMAScript)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Metadata Reflection"})}),(0,s.jsxs)(n.td,{children:["Requires ",(0,s.jsx)(n.code,{children:"reflect-metadata"})]}),(0,s.jsxs)(n.td,{children:["Does not rely on ",(0,s.jsx)(n.code,{children:"reflect-metadata"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Supported Targets"})}),(0,s.jsx)(n.td,{children:"Classes, methods, properties, accessors, parameters"}),(0,s.jsx)(n.td,{children:"Class elements (methods, fields, accessors)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Parameter Decorators"})}),(0,s.jsx)(n.td,{children:"Supported"}),(0,s.jsx)(n.td,{children:"Not supported"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Context Object"})}),(0,s.jsx)(n.td,{children:"Not available"}),(0,s.jsxs)(n.td,{children:["Provides ",(0,s.jsx)(n.code,{children:"context"})," object"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Compiler Options"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'"experimentalDecorators": true'})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:'"experimentalDecorators": true'})," and ",(0,s.jsx)(n.code,{children:'"useDefineForClassFields": true'})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Order of Execution"})}),(0,s.jsx)(n.td,{children:"Parameter \u2192 Method/Accessor \u2192 Property \u2192 Class"}),(0,s.jsx)(n.td,{children:"Class elements only"})]})]})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"which-one-should-you-use",children:(0,s.jsx)(n.strong,{children:"Which One Should You Use?"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Experimental Decorators"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Use if you're working with older TypeScript projects or frameworks like Angular that rely on the experimental decorator implementation."}),"\n",(0,s.jsxs)(n.li,{children:["Requires ",(0,s.jsx)(n.code,{children:"reflect-metadata"})," for advanced use cases."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"ECMAScript Decorators"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Use if you're targeting modern JavaScript and want to align with the ECMAScript standard."}),"\n",(0,s.jsx)(n.li,{children:"Provides a cleaner and more standardized API."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"conclusion",children:(0,s.jsx)(n.strong,{children:"Conclusion"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Experimental decorators are TypeScript's legacy implementation, while ECMAScript decorators are the standardized version."}),"\n",(0,s.jsx)(n.li,{children:"As ECMAScript decorators become widely adopted, they are expected to replace experimental decorators in the long term."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>a});var t=r(96540);const s={},o=t.createContext(s);function i(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);