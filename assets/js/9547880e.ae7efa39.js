"use strict";(self.webpackChunkwiki=self.webpackChunkwiki||[]).push([[6959],{82223:(e,n,s)=>{s.d(n,{A:()=>l});s(96540);var i=s(34164);const r={tabItem:"tabItem_Ymn6"};var t=s(74848);function l(e){let{children:n,hidden:s,className:l}=e;return(0,t.jsx)("div",{role:"tabpanel",className:(0,i.A)(r.tabItem,l),hidden:s,children:n})}},72206:(e,n,s)=>{s.d(n,{A:()=>y});var i=s(96540),r=s(34164),t=s(80052),l=s(56347),c=s(35793),d=s(99025),o=s(4430),a=s(44148);function h(e){return i.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,i.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function x(e){const{values:n,children:s}=e;return(0,i.useMemo)((()=>{const e=n??function(e){return h(e).map((e=>{let{props:{value:n,label:s,attributes:i,default:r}}=e;return{value:n,label:s,attributes:i,default:r}}))}(s);return function(e){const n=(0,o.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,s])}function u(e){let{value:n,tabValues:s}=e;return s.some((e=>e.value===n))}function j(e){let{queryString:n=!1,groupId:s}=e;const r=(0,l.W6)(),t=function(e){let{queryString:n=!1,groupId:s}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!s)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return s??null}({queryString:n,groupId:s});return[(0,d.aZ)(t),(0,i.useCallback)((e=>{if(!t)return;const n=new URLSearchParams(r.location.search);n.set(t,e),r.replace({...r.location,search:n.toString()})}),[t,r])]}function m(e){const{defaultValue:n,queryString:s=!1,groupId:r}=e,t=x(e),[l,d]=(0,i.useState)((()=>function(e){let{defaultValue:n,tabValues:s}=e;if(0===s.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!u({value:n,tabValues:s}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${s.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const i=s.find((e=>e.default))??s[0];if(!i)throw new Error("Unexpected error: 0 tabValues");return i.value}({defaultValue:n,tabValues:t}))),[o,h]=j({queryString:s,groupId:r}),[m,p]=function(e){let{groupId:n}=e;const s=function(e){return e?`docusaurus.tab.${e}`:null}(n),[r,t]=(0,a.Dv)(s);return[r,(0,i.useCallback)((e=>{s&&t.set(e)}),[s,t])]}({groupId:r}),g=(()=>{const e=o??m;return u({value:e,tabValues:t})?e:null})();(0,c.A)((()=>{g&&d(g)}),[g]);return{selectedValue:l,selectValue:(0,i.useCallback)((e=>{if(!u({value:e,tabValues:t}))throw new Error(`Can't select invalid tab value=${e}`);d(e),h(e),p(e)}),[h,p,t]),tabValues:t}}var p=s(75251);const g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var f=s(74848);function z(e){let{className:n,block:s,selectedValue:i,selectValue:l,tabValues:c}=e;const d=[],{blockElementScrollPositionUntilNextRender:o}=(0,t.a_)(),a=e=>{const n=e.currentTarget,s=d.indexOf(n),r=c[s].value;r!==i&&(o(n),l(r))},h=e=>{let n=null;switch(e.key){case"Enter":a(e);break;case"ArrowRight":{const s=d.indexOf(e.currentTarget)+1;n=d[s]??d[0];break}case"ArrowLeft":{const s=d.indexOf(e.currentTarget)-1;n=d[s]??d[d.length-1];break}}n?.focus()};return(0,f.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":s},n),children:c.map((e=>{let{value:n,label:s,attributes:t}=e;return(0,f.jsx)("li",{role:"tab",tabIndex:i===n?0:-1,"aria-selected":i===n,ref:e=>{d.push(e)},onKeyDown:h,onClick:a,...t,className:(0,r.A)("tabs__item",g.tabItem,t?.className,{"tabs__item--active":i===n}),children:s??n},n)}))})}function b(e){let{lazy:n,children:s,selectedValue:t}=e;const l=(Array.isArray(s)?s:[s]).filter(Boolean);if(n){const e=l.find((e=>e.props.value===t));return e?(0,i.cloneElement)(e,{className:(0,r.A)("margin-top--md",e.props.className)}):null}return(0,f.jsx)("div",{className:"margin-top--md",children:l.map(((e,n)=>(0,i.cloneElement)(e,{key:n,hidden:e.props.value!==t})))})}function v(e){const n=m(e);return(0,f.jsxs)("div",{className:(0,r.A)("tabs-container",g.tabList),children:[(0,f.jsx)(z,{...n,...e}),(0,f.jsx)(b,{...n,...e})]})}function y(e){const n=(0,p.A)();return(0,f.jsx)(v,{...e,children:h(e.children)},String(n))}},48486:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>u,frontMatter:()=>d,metadata:()=>i,toc:()=>h});const i=JSON.parse('{"id":"js-tips/hacker-rank","title":"Hacker Rank - Part 1","description":"Number of duplicates","source":"@site/docs/js-tips/hacker-rank.mdx","sourceDirName":"js-tips","slug":"/js-tips/hacker-rank","permalink":"/wiki/docs/js-tips/hacker-rank","draft":false,"unlisted":false,"editUrl":"https://github.com/actionanand/wiki/docs/js-tips/hacker-rank.mdx","tags":[],"version":"current","sidebarPosition":13,"frontMatter":{"sidebar_position":13,"sidebar_label":"Hacker Rank part-1"},"sidebar":"tutorialSidebar","previous":{"title":"Decorator in Typescript","permalink":"/wiki/docs/js-tips/decorator"},"next":{"title":"RxJs Tips","permalink":"/wiki/docs/category/rxjs-tips"}}');var r=s(74848),t=s(28453),l=s(72206),c=s(82223);const d={sidebar_position:13,sidebar_label:"Hacker Rank part-1"},o="Hacker Rank - Part 1",a={},h=[{value:"Number of duplicates",id:"number-of-duplicates",level:2},{value:"<strong>Comparison with Original Code</strong>",id:"comparison-with-original-code",level:3},{value:"Minimum number of recommendation engines required",id:"minimum-number-of-recommendation-engines-required",level:2},{value:"<strong>Problem Explanation</strong>",id:"problem-explanation",level:3},{value:"<strong>Approach to Solve the Problem</strong>",id:"approach-to-solve-the-problem",level:3},{value:"<strong>Steps</strong>:",id:"steps",level:4},{value:"<strong>Example Walkthrough</strong>",id:"example-walkthrough",level:3},{value:"Input:",id:"input",level:4},{value:"Steps:",id:"steps-1",level:4},{value:"<strong>Code Implementation</strong>",id:"code-implementation",level:3},{value:"<strong>Key Points</strong>",id:"key-points",level:3},{value:"<strong>Conclusion</strong>",id:"conclusion",level:3},{value:"FizzBuzz",id:"fizzbuzz",level:2},{value:"<strong>Explanation</strong>",id:"explanation",level:3},{value:"<strong>Time Complexity</strong>",id:"time-complexity",level:3},{value:"<strong>Space Complexity</strong>",id:"space-complexity",level:3},{value:"<strong>Time Complexity</strong>",id:"time-complexity-1",level:3},{value:"<strong>Space Complexity</strong>",id:"space-complexity-1",level:3},{value:"FizzBuzz using bitmask",id:"fizzbuzz-using-bitmask",level:2},{value:"<strong>Key Components</strong>",id:"key-components",level:3},{value:"<strong>How It Works</strong>",id:"how-it-works",level:3},{value:"<strong>Advantages</strong>",id:"advantages",level:3},{value:"<strong>Time Complexity</strong>",id:"time-complexity-2",level:3},{value:"<strong>Space Complexity</strong>",id:"space-complexity-2",level:3}];function x(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"hacker-rank---part-1",children:"Hacker Rank - Part 1"})}),"\n",(0,r.jsx)(n.h2,{id:"number-of-duplicates",children:"Number of duplicates"}),"\n",(0,r.jsxs)(n.p,{children:["Write a TypeScript function that takes three arrays (",(0,r.jsx)(n.code,{children:"names"}),", ",(0,r.jsx)(n.code,{children:"prices"}),", and ",(0,r.jsx)(n.code,{children:"weights"}),") as input, where each index represents an item with its name, price, and weight. The function should determine the number of unique duplicate items based on the combination of name, price, and weight. For example, given the inputs:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"const names = ['apple', 'mango', 'apple', 'banana', 'apple'];\nconst prices = [20, 20, 30, 30, 30];\nconst weights = [1, 3, 1, 3, 1];\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The function should return ",(0,r.jsx)(n.code,{children:"1"})," because the combination of ",(0,r.jsx)(n.code,{children:"name[2]"}),", ",(0,r.jsx)(n.code,{children:"price[2]"}),", ",(0,r.jsx)(n.code,{children:"weight[2]"})," and ",(0,r.jsx)(n.code,{children:"name[4]"}),", ",(0,r.jsx)(n.code,{children:"price[4]"}),", ",(0,r.jsx)(n.code,{children:"weight[4]"})," is a duplicate. Implement the function and explain how it works."]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Index"}),(0,r.jsx)(n.th,{children:"Name"}),(0,r.jsx)(n.th,{children:"Price"}),(0,r.jsx)(n.th,{children:"Weight"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"0"}),(0,r.jsx)(n.td,{children:"apple"}),(0,r.jsx)(n.td,{children:"20"}),(0,r.jsx)(n.td,{children:"1"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"1"}),(0,r.jsx)(n.td,{children:"mango"}),(0,r.jsx)(n.td,{children:"20"}),(0,r.jsx)(n.td,{children:"3"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"2"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"apple"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"30"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"1"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"3"}),(0,r.jsx)(n.td,{children:"banana"}),(0,r.jsx)(n.td,{children:"30"}),(0,r.jsx)(n.td,{children:"3"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"4"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"apple"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"30"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"1"})})]})]})]}),"\n",(0,r.jsxs)(l.A,{children:[(0,r.jsx)(c.A,{value:"own",label:"My Idea",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function findDuplicates(names: string[], prices: number[], weights: number[]): number {\n  const arr: string[] = [];\n\n  names.forEach((el, i) => {\n    prices.forEach((rs, j) => {\n      weights.forEach((kg, k) => {\n        if (i === j && i === k) {\n          arr.push(`${names[i]}-${prices[j]}-${weights[k]}`);\n        }\n      });\n    });\n  });\n\n  // the total time complexity of the above nested loops is: O(n\xb3).\n\n  const dupl = arr.filter((value, i) => arr.indexOf(value) !== i);\n\n  // The `filter` method runs in O(n\xb2) because for each element, it performs an `indexOf` operation\n\n  return dupl.length;\n}\n"})})}),(0,r.jsx)(c.A,{value:"set",label:"Optimized Code",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function findDuplicates(names: string[], prices: number[], weights: number[]): number {\n  const seen = new Set<string>(); // To track unique combinations\n  const duplicates = new Set<string>(); // To track duplicates\n\n  names.forEach((_, i) => {\n    // Create a unique key for each combination of name, price, and weight\n    const key = `${names[i]}-${prices[i]}-${weights[i]}`;\n\n    if (seen.has(key)) {\n      // If the key is already in the set, it's a duplicate\n      duplicates.add(key);\n    } else {\n      // Otherwise, add it to the seen set\n      seen.add(key);\n    }\n  });\n\n  return duplicates.size; // Return the number of unique duplicate combinations\n}\n"})})})]}),"\n",(0,r.jsx)(n.h3,{id:"comparison-with-original-code",children:(0,r.jsx)(n.strong,{children:"Comparison with Original Code"})}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Feature"}),(0,r.jsx)(n.th,{children:"Original Code"}),(0,r.jsx)(n.th,{children:"Optimized Code"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Time Complexity"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"O(n\xb3 + n\xb2)"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"O(n)"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Space Complexity"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.strong,{children:"O(n)"})," (due to ",(0,r.jsx)(n.code,{children:"arr"}),")"]}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.strong,{children:"O(n)"})," (due to ",(0,r.jsx)(n.code,{children:"Set"}),")"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Duplicate Detection"})}),(0,r.jsxs)(n.td,{children:["Uses ",(0,r.jsx)(n.code,{children:"filter"})," and ",(0,r.jsx)(n.code,{children:"indexOf"})]}),(0,r.jsxs)(n.td,{children:["Uses ",(0,r.jsx)(n.code,{children:"Set"})," for constant-time checks"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Readability"})}),(0,r.jsx)(n.td,{children:"More complex with nested loops"}),(0,r.jsx)(n.td,{children:"Simplified with a single loop"})]})]})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://www.freecodecamp.org/news/big-o-cheat-sheet-time-complexity-chart/",children:"Big O Cheat Sheet \u2013 Time Complexity Chart"})}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"minimum-number-of-recommendation-engines-required",children:"Minimum number of recommendation engines required"}),"\n",(0,r.jsxs)(n.p,{children:["This problem is about determining the ",(0,r.jsx)(n.strong,{children:"minimum number of recommendation engines"})," required to process overlapping user sessions on an online streaming platform. Each session has a start and end time, and each session requires exactly one recommendation engine. The goal is to calculate how many engines are needed to handle all sessions without conflicts."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"problem-explanation",children:(0,r.jsx)(n.strong,{children:"Problem Explanation"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Input"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["A 2D array ",(0,r.jsx)(n.code,{children:"sessionTimings"})," of size ",(0,r.jsx)(n.code,{children:"n x 2"}),", where each element represents ",(0,r.jsx)(n.code,{children:"[startTime, endTime]"})," of a session."]}),"\n",(0,r.jsxs)(n.li,{children:["Example:","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"const sessionTimings = [\n  [1, 4], // Session 1: Starts at time 1, ends at time 4\n  [2, 5], // Session 2: Starts at time 2, ends at time 5\n  [7, 9], // Session 3: Starts at time 7, ends at time 9\n];\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Output"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The minimum number of recommendation engines required to process all sessions."}),"\n",(0,r.jsxs)(n.li,{children:["Example:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["For the above input, the output is ",(0,r.jsx)(n.code,{children:"2"})," because:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Session 1 and Session 2 overlap, so two engines are needed."}),"\n",(0,r.jsx)(n.li,{children:"Session 3 does not overlap with the others, so only one engine is needed for it."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Key Constraints"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Each session requires exactly one recommendation engine."}),"\n",(0,r.jsx)(n.li,{children:"If two or more sessions overlap, they cannot share the same engine."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"approach-to-solve-the-problem",children:(0,r.jsx)(n.strong,{children:"Approach to Solve the Problem"})}),"\n",(0,r.jsx)(n.p,{children:"To solve this problem, we need to determine the maximum number of overlapping sessions at any point in time. This will tell us the minimum number of engines required."}),"\n",(0,r.jsxs)(n.h4,{id:"steps",children:[(0,r.jsx)(n.strong,{children:"Steps"}),":"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Separate Start and End Times"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Extract all start times and end times from the input array."}),"\n",(0,r.jsx)(n.li,{children:"Sort both arrays in ascending order."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use Two Pointers"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Use two pointers (",(0,r.jsx)(n.code,{children:"startPointer"})," and ",(0,r.jsx)(n.code,{children:"endPointer"}),") to iterate through the sorted start and end times."]}),"\n",(0,r.jsxs)(n.li,{children:["Keep track of the number of active sessions (",(0,r.jsx)(n.code,{children:"activeSessions"}),") at any given time."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Count Overlaps"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["If a session starts before the previous session ends (",(0,r.jsx)(n.code,{children:"startTime < endTime"}),"), increment the ",(0,r.jsx)(n.code,{children:"activeSessions"})," count."]}),"\n",(0,r.jsxs)(n.li,{children:["If a session ends (",(0,r.jsx)(n.code,{children:"startTime >= endTime"}),"), decrement the ",(0,r.jsx)(n.code,{children:"activeSessions"})," count."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Track Maximum Overlaps"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Keep track of the maximum value of ",(0,r.jsx)(n.code,{children:"activeSessions"})," during the iteration. This value represents the minimum number of recommendation engines required."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"example-walkthrough",children:(0,r.jsx)(n.strong,{children:"Example Walkthrough"})}),"\n",(0,r.jsx)(n.h4,{id:"input",children:"Input:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"const sessionTimings = [\n  [1, 4],\n  [2, 5],\n  [7, 9],\n  [3, 6],\n];\n"})}),"\n",(0,r.jsx)(n.h4,{id:"steps-1",children:"Steps:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Extract and Sort Start and End Times"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Start times: ",(0,r.jsx)(n.code,{children:"[1, 2, 3, 7]"})]}),"\n",(0,r.jsxs)(n.li,{children:["End times: ",(0,r.jsx)(n.code,{children:"[4, 5, 6, 9]"})]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Iterate Using Two Pointers"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Initialize ",(0,r.jsx)(n.code,{children:"activeSessions = 0"})," and ",(0,r.jsx)(n.code,{children:"maxEngines = 0"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Compare ",(0,r.jsx)(n.code,{children:"startTimes[startPointer]"})," with ",(0,r.jsx)(n.code,{children:"endTimes[endPointer]"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["At ",(0,r.jsx)(n.code,{children:"startTime = 1"}),": Increment ",(0,r.jsx)(n.code,{children:"activeSessions"})," to ",(0,r.jsx)(n.code,{children:"1"}),". Update ",(0,r.jsx)(n.code,{children:"maxEngines = 1"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["At ",(0,r.jsx)(n.code,{children:"startTime = 2"}),": Increment ",(0,r.jsx)(n.code,{children:"activeSessions"})," to ",(0,r.jsx)(n.code,{children:"2"}),". Update ",(0,r.jsx)(n.code,{children:"maxEngines = 2"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["At ",(0,r.jsx)(n.code,{children:"startTime = 3"}),": Increment ",(0,r.jsx)(n.code,{children:"activeSessions"})," to ",(0,r.jsx)(n.code,{children:"3"}),". Update ",(0,r.jsx)(n.code,{children:"maxEngines = 3"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["At ",(0,r.jsx)(n.code,{children:"endTime = 4"}),": Decrement ",(0,r.jsx)(n.code,{children:"activeSessions"})," to ",(0,r.jsx)(n.code,{children:"2"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["At ",(0,r.jsx)(n.code,{children:"endTime = 5"}),": Decrement ",(0,r.jsx)(n.code,{children:"activeSessions"})," to ",(0,r.jsx)(n.code,{children:"1"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["At ",(0,r.jsx)(n.code,{children:"startTime = 7"}),": Increment ",(0,r.jsx)(n.code,{children:"activeSessions"})," to ",(0,r.jsx)(n.code,{children:"2"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["At ",(0,r.jsx)(n.code,{children:"endTime = 6"}),": Decrement ",(0,r.jsx)(n.code,{children:"activeSessions"})," to ",(0,r.jsx)(n.code,{children:"1"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Result"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The maximum value of ",(0,r.jsx)(n.code,{children:"activeSessions"})," is ",(0,r.jsx)(n.code,{children:"3"}),", so ",(0,r.jsx)(n.code,{children:"3"})," recommendation engines are required."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"code-implementation",children:(0,r.jsx)(n.strong,{children:"Code Implementation"})}),"\n",(0,r.jsx)(n.p,{children:"Here is the TypeScript implementation:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function minRecommendationEngines(sessions: number[][]): number {\n  if (sessions.length === 0) {\n    return 0;\n  }\n\n  // Separate start and end times into two arrays\n  const startTimes = sessions.map(session => session[0]).sort((a, b) => a - b);\n  const endTimes = sessions.map(session => session[1]).sort((a, b) => a - b);\n\n  let enginesRequired = 0;\n  let activeSessions = 0;\n  let startPointer = 0;\n  let endPointer = 0;\n\n  // Iterate through all start times\n  while (startPointer < startTimes.length) {\n    if (startTimes[startPointer] < endTimes[endPointer]) {\n      // A new session starts before the current session ends\n      activeSessions++;\n      enginesRequired = Math.max(enginesRequired, activeSessions);\n      startPointer++;\n    } else {\n      // A session ends\n      activeSessions--;\n      endPointer++;\n    }\n  }\n\n  return enginesRequired;\n}\n\n// Example usage\nconst sessions = [\n  [1, 4],\n  [2, 5],\n  [7, 9],\n  [3, 6],\n];\nconsole.log(minRecommendationEngines(sessions)); // Output: 3\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"key-points",children:(0,r.jsx)(n.strong,{children:"Key Points"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Sorting"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Sorting the start and end times ensures that we process sessions in chronological order."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Two Pointers"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The two-pointer technique efficiently tracks overlapping sessions without needing nested loops."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Time Complexity"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Sorting the start and end times: ",(0,r.jsx)(n.code,{children:"O(n log n)"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Iterating through the sessions: ",(0,r.jsx)(n.code,{children:"O(n)"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Overall complexity: ",(0,r.jsx)(n.code,{children:"O(n log n)"}),"."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Space Complexity"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Storing start and end times: ",(0,r.jsx)(n.code,{children:"O(n)"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"conclusion",children:(0,r.jsx)(n.strong,{children:"Conclusion"})}),"\n",(0,r.jsx)(n.p,{children:"This approach efficiently calculates the minimum number of recommendation engines required by determining the maximum number of overlapping sessions at any point in time. It uses sorting and the two-pointer technique to achieve optimal performance."}),"\n",(0,r.jsx)(n.h2,{id:"fizzbuzz",children:"FizzBuzz"}),"\n",(0,r.jsxs)(l.A,{children:[(0,r.jsx)(c.A,{value:"custom",label:"Traditional",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'function fizzBuzz(n: number): void {\n  for (let i = 1; i <= n; i++) {\n    if (i % 3 === 0 && i % 5 === 0) {\n      console.log("FizzBuzz");\n    } else if (i % 3 === 0) {\n      console.log("Fizz");\n    } else if (i % 5 === 0) {\n      console.log("Buzz");\n    } else {\n      console.log(i);\n    }\n  }\n}\n\n// Example usage\nfizzBuzz(15);\n'})})}),(0,r.jsx)(c.A,{value:"own",label:"My Idea",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function fizzBuzz(n: number): void {\n  Array.from({ length: n }, (_, i) => {\n    const index = i + 1; // Adjust index to start from 1\n    if (index % 3 === 0 && index % 5 === 0) {\n      console.log('FizzBuzz');\n    } else if (index % 3 === 0) {\n      console.log('Fizz');\n    } else if (index % 5 === 0) {\n      console.log('Buzz');\n    } else {\n      console.log(index);\n    }\n  });\n}\n\nfizzBuzz(15);\n"})})}),(0,r.jsx)(c.A,{value:"without",label:"Without %",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'function fizzBuzzWithoutMod(n: number): void {\n  let fizz = 3; // Counter for "Fizz"\n  let buzz = 5; // Counter for "Buzz"\n\n  for (let i = 1; i <= n; i++) {\n    let output = "";\n\n    if (fizz === 0 && buzz === 0) {\n      output = "FizzBuzz";\n      fizz = 3; // Reset Fizz counter\n      buzz = 5; // Reset Buzz counter\n    } else if (fizz === 0) {\n      output = "Fizz";\n      fizz = 3; // Reset Fizz counter\n    } else if (buzz === 0) {\n      output = "Buzz";\n      buzz = 5; // Reset Buzz counter\n    } else {\n      output = i.toString();\n    }\n\n    console.log(output);\n\n    fizz--; // Decrement Fizz counter\n    buzz--; // Decrement Buzz counter\n  }\n}\n\n// Example usage\nfizzBuzzWithoutMod(15);\n'})})})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"explanation",children:(0,r.jsx)(n.strong,{children:"Explanation"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Input"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The function takes an integer ",(0,r.jsx)(n.code,{children:"n"})," as input, which represents the range of numbers to process (from ",(0,r.jsx)(n.code,{children:"1"})," to ",(0,r.jsx)(n.code,{children:"n"}),")."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Logic"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["For each number ",(0,r.jsx)(n.code,{children:"i"})," from ",(0,r.jsx)(n.code,{children:"1"})," to ",(0,r.jsx)(n.code,{children:"n"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["If ",(0,r.jsx)(n.code,{children:"i"})," is divisible by both ",(0,r.jsx)(n.code,{children:"3"})," and ",(0,r.jsx)(n.code,{children:"5"}),", print ",(0,r.jsx)(n.code,{children:'"FizzBuzz"'}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["If ",(0,r.jsx)(n.code,{children:"i"})," is divisible by ",(0,r.jsx)(n.code,{children:"3"})," only, print ",(0,r.jsx)(n.code,{children:'"Fizz"'}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["If ",(0,r.jsx)(n.code,{children:"i"})," is divisible by ",(0,r.jsx)(n.code,{children:"5"})," only, print ",(0,r.jsx)(n.code,{children:'"Buzz"'}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Otherwise, print the number ",(0,r.jsx)(n.code,{children:"i"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Output"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["For ",(0,r.jsx)(n.code,{children:"n = 15"}),", the output will be:","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"1\n2\nFizz\n4\nBuzz\nFizz\n7\n8\nFizz\nBuzz\n11\nFizz\n13\n14\nFizzBuzz\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"time-complexity",children:(0,r.jsx)(n.strong,{children:"Time Complexity"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The loop runs from ",(0,r.jsx)(n.code,{children:"1"})," to ",(0,r.jsx)(n.code,{children:"n"}),", so the time complexity is ",(0,r.jsx)(n.strong,{children:"O(n)"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"space-complexity",children:(0,r.jsx)(n.strong,{children:"Space Complexity"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The function uses constant space, so the space complexity is ",(0,r.jsx)(n.strong,{children:"O(1)"}),".---"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"time-complexity-1",children:(0,r.jsx)(n.strong,{children:"Time Complexity"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The loop runs from ",(0,r.jsx)(n.code,{children:"1"})," to ",(0,r.jsx)(n.code,{children:"n"}),", so the time complexity is ",(0,r.jsx)(n.strong,{children:"O(n)"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"space-complexity-1",children:(0,r.jsx)(n.strong,{children:"Space Complexity"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The function uses constant space, so the space complexity is ",(0,r.jsx)(n.strong,{children:"O(1)"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"fizzbuzz-using-bitmask",children:"FizzBuzz using bitmask"}),"\n",(0,r.jsxs)(n.p,{children:["This code implements the ",(0,r.jsx)(n.strong,{children:"FizzBuzz"})," logic using a ",(0,r.jsx)(n.strong,{children:"bitmask"})," (",(0,r.jsx)(n.code,{children:"mask"}),") and a predefined array of words (",(0,r.jsx)(n.code,{children:"words"}),"). Here's how it works:"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"key-components",children:(0,r.jsx)(n.strong,{children:"Key Components"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"words"})," Array"]}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"const words = [undefined, 'Fizz', 'Buzz', 'FizzBuzz'];\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["This array maps the values ",(0,r.jsx)(n.code,{children:"1"}),", ",(0,r.jsx)(n.code,{children:"2"}),", and ",(0,r.jsx)(n.code,{children:"3"})," to ",(0,r.jsx)(n.code,{children:'"Fizz"'}),", ",(0,r.jsx)(n.code,{children:'"Buzz"'}),", and ",(0,r.jsx)(n.code,{children:'"FizzBuzz"'}),", respectively."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"undefined"})," is used for numbers that are not divisible by ",(0,r.jsx)(n.code,{children:"3"})," or ",(0,r.jsx)(n.code,{children:"5"}),"."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"mask"})}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"let mask = 810092048; // Binary: 11 00 00 01 00 10 01 00 00 01 10 00 01 00 00\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The ",(0,r.jsx)(n.code,{children:"mask"})," is a 30-bit binary number that encodes the FizzBuzz pattern for numbers from ",(0,r.jsx)(n.code,{children:"1"})," to ",(0,r.jsx)(n.code,{children:"15"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Each pair of bits (",(0,r.jsx)(n.code,{children:"00"}),", ",(0,r.jsx)(n.code,{children:"01"}),", ",(0,r.jsx)(n.code,{children:"10"}),", ",(0,r.jsx)(n.code,{children:"11"}),") represents:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"00"}),": A number that is neither divisible by ",(0,r.jsx)(n.code,{children:"3"})," nor ",(0,r.jsx)(n.code,{children:"5"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"01"}),": A number divisible by ",(0,r.jsx)(n.code,{children:"3"})," (Fizz)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"10"}),": A number divisible by ",(0,r.jsx)(n.code,{children:"5"})," (Buzz)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"11"}),": A number divisible by both ",(0,r.jsx)(n.code,{children:"3"})," and ",(0,r.jsx)(n.code,{children:"5"})," (FizzBuzz)."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Bitwise Operations"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Extracting the Current Value"}),":","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"const c = mask & 3;\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The ",(0,r.jsx)(n.code,{children:"& 3"})," operation extracts the last two bits of the ",(0,r.jsx)(n.code,{children:"mask"})," (the current FizzBuzz value)."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Updating the Mask"}),":","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"mask = (mask >> 2) | (c << 28);\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The ",(0,r.jsx)(n.code,{children:"mask"})," is shifted right by 2 bits (",(0,r.jsx)(n.code,{children:">> 2"}),") to process the next value."]}),"\n",(0,r.jsxs)(n.li,{children:["The extracted value (",(0,r.jsx)(n.code,{children:"c"}),") is shifted left by 28 bits (",(0,r.jsx)(n.code,{children:"c << 28"}),") and added back to the mask to maintain the circular pattern."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Logic"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["If ",(0,r.jsx)(n.code,{children:"c"})," is ",(0,r.jsx)(n.code,{children:"1"}),", ",(0,r.jsx)(n.code,{children:"2"}),", or ",(0,r.jsx)(n.code,{children:"3"}),", the corresponding word (",(0,r.jsx)(n.code,{children:"Fizz"}),", ",(0,r.jsx)(n.code,{children:"Buzz"}),", or ",(0,r.jsx)(n.code,{children:"FizzBuzz"}),") is printed."]}),"\n",(0,r.jsxs)(n.li,{children:["If ",(0,r.jsx)(n.code,{children:"c"})," is ",(0,r.jsx)(n.code,{children:"0"}),", the current number (",(0,r.jsx)(n.code,{children:"i"}),") is printed."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"how-it-works",children:(0,r.jsx)(n.strong,{children:"How It Works"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["The ",(0,r.jsx)(n.code,{children:"mask"})," encodes the FizzBuzz pattern for numbers from ",(0,r.jsx)(n.code,{children:"1"})," to ",(0,r.jsx)(n.code,{children:"15"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["The loop iterates from ",(0,r.jsx)(n.code,{children:"1"})," to ",(0,r.jsx)(n.code,{children:"100"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["For each number:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The last two bits of the ",(0,r.jsx)(n.code,{children:"mask"})," determine whether to print ",(0,r.jsx)(n.code,{children:'"Fizz"'}),", ",(0,r.jsx)(n.code,{children:'"Buzz"'}),", ",(0,r.jsx)(n.code,{children:'"FizzBuzz"'}),", or the number itself."]}),"\n",(0,r.jsxs)(n.li,{children:["The ",(0,r.jsx)(n.code,{children:"mask"})," is updated to maintain the circular FizzBuzz pattern."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.p,{children:["This pattern repeats every 15 numbers, so the output for numbers from ",(0,r.jsx)(n.code,{children:"1"})," to ",(0,r.jsx)(n.code,{children:"100"})," will follow the same FizzBuzz logic."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"advantages",children:(0,r.jsx)(n.strong,{children:"Advantages"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Efficient"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The FizzBuzz logic is precomputed and encoded in the ",(0,r.jsx)(n.code,{children:"mask"}),", reducing the need for modulus operations (",(0,r.jsx)(n.code,{children:"%"}),")."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Compact"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The use of bitwise operations makes the implementation concise and avoids repetitive conditionals."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"time-complexity-2",children:(0,r.jsx)(n.strong,{children:"Time Complexity"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The loop runs from ",(0,r.jsx)(n.code,{children:"1"})," to ",(0,r.jsx)(n.code,{children:"100"}),", so the time complexity is ",(0,r.jsx)(n.strong,{children:"O(n)"}),", where ",(0,r.jsx)(n.code,{children:"n"})," is the range of numbers."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"space-complexity-2",children:(0,r.jsx)(n.strong,{children:"Space Complexity"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The space complexity is ",(0,r.jsx)(n.strong,{children:"O(1)"}),", as the ",(0,r.jsx)(n.code,{children:"mask"})," and ",(0,r.jsx)(n.code,{children:"words"})," array use constant space."]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(x,{...e})}):x(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>c});var i=s(96540);const r={},t=i.createContext(r);function l(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);